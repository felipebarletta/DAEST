---
title: "Módulo 3"
output:
  html_document:
    toc: false
    code_folding: show
---

```{r setup, include=FALSE, cache=FALSE}
#source("setup_knitr.R")
knitr::opts_chunk$set(echo = TRUE,
                      comment = NA,
                      warning = FALSE,
                      message = FALSE)
```

# Correlação (27/10/20)

## Exemplos de possíveis correlações


```{r}
# Diagrama de dispersão
# Plotando todos no mesmo gráfico
par(mfrow=c(2,3))
# Correlação perfeita positiva
x<-seq(-100, 100)
y1<-x*2.53
plot(x, y1, main = "Correlação perfeita positiva",ylab = "y",col="blue")

# Correlação perfeita negativa
x<-seq(-100, 100)
y2<- -x*2.53
plot(x, y2, main = "Correlação perfeita negativa",ylab = "y",col="blue")

# Alta correlação positiva
y3<-rnorm(y1,y1,20)
plot(x,y3,main="Alta correlação positiva",ylab = "y",col="blue")

# Alta correlação
y4<-rnorm(y1,(-1)*y1,20)
plot(x,y4,main="Alta correlação negativa",ylab = "y",col="blue")

# Baixa correlação positiva
y5<-rnorm(y1,y1,500)
plot(x,y5,main="Baixa correlação",ylab = "y",col="blue")

# Correlação não linear
y6<- rnorm(x, x^2, 1000)
plot(x,y6,main="Correlação não linear",ylab = "y",col="blue")

```

## Exercício 1

```{r}
distancia<-scan(text="20.00 60.00 15.00 45.00 35.00 80.00 70.00 73.00 28.00 85.00")
consumo<-scan(text=" 1.33 5.45 1.66 3.46 2.92 6.15 4.11 5.00 2.95 6.54")

#Cálculo da correlação linear simples
xbarra<-mean(distancia)
ybarra<-mean(consumo)
sumxy<-sum(distancia*consumo)
sumx2<-sum(distancia^2)
sumy2<-sum(consumo^2)
n<-length(consumo)
r<-(sumxy-n*xbarra*ybarra) / (sqrt((sumx2-n*(xbarra^2))*(sumy2-n*(ybarra^2))))
r
r^2

```

```{r}
# Crianção da função para a correlação e coeficiente de determinação
correlacao<-function(x,y){
  sumxy<-sum(x*y)
  xbarra<-mean(x)
  ybarra<-mean(y)
  sumx2<-sum(x^2)
  sumy2<-sum(y^2)
  n<-length(x)
  r<-(sumxy-n*xbarra*ybarra) / (sqrt((sumx2-n*(xbarra^2))*(sumy2-n*(ybarra^2))))
  r2<-r^2
  return(list(coef.correlacao=r,coef.determinacao=r2))
}
correlacao(distancia,consumo)

```


```{r}
# Função disponível no R
cor(consumo,distancia)

```


```{r}
# Diagrama de dispersão x= Distância y= Consumo
plot(distancia, consumo, main="Consumo x Distância", ylab= "Consumo (l)", xlab="Distância (km)",
     pch=16, col="blue",cex.main=1.5, cex=1.5,cex.lab=1.2, cex.axis=1,bty="l")
abline(h=seq(0,7,1), v=seq(0,90, 10), lty=3, col="gray")
text(30,5, "r=-0.95 ",col = "red",cex = 1.2)
text(30,4.5, "r2=0.90",col = "red",cex = 1.2)

```

```{r}
# Criação da função do teste
test.c<-function(r,n){
  t<-r*sqrt((n-2)/(1-r^2))
  return(t)
}

```


```{r}
# Usando a função com o valor de r arredondado
r<-0.95
n<-10
test.c(r,n)
alpha<-0.05
inf<-qt(alpha/2, df = n-2)
sup<-qt(1-(alpha/2), df = n-2)

```


```{r}
# Fazendo o teste de hipóteses (t.calc > -t.crit | t.calc < +t.crit)
test.c(r,n) < inf | test.c(r,n) > sup
# Fazendo o teste (|t.calc|>|t.crit|)
abs(test.c(r,n)) > sup
# Rejeitamos H0. Há correlação, com 95% de confiança.

```




```{r}
# Usando a função disponível no R
cor.test(distancia,consumo)

```


```{r}
# Acréscimo na função anterior - opção 1
correlacao<-function(x,y){
  sumxy<-sum(x*y)
  xbarra<-mean(x)
  ybarra<-mean(y)
  sumx2<-sum(x^2)
  sumy2<-sum(y^2)
  n<-length(x)
  r<-(sumxy-n*xbarra*ybarra) / (sqrt((sumx2-n*(xbarra^2))*(sumy2-n*(ybarra^2))))
  r2<-r^2
  t<-r*sqrt((n-2)/(1-r^2))
  return(list(coef.correlacao=r,coef.determinacao=r2, teste.calc=t))
}
correlacao(distancia,consumo)

```


```{r}
# Usando a função sem arredondamento - opção 2
r<-cor(distancia,consumo)
n<-10
test.c(r,n)

```
```{r}
# Construção do teste graficamente
x <- seq(- 10, 10, by = 0.01) 
fx<-dt(x, df=n-2)
plot(x,fx, type="l", col='black',cex.main=1.5, cex=1.5,cex.lab=1.2, cex.axis=1,bty="l")
polygon(x = c(2.306004, seq(2.306004, 10, 0.01), 10),
        y = c(0, dt(seq(2.306004, 10,  0.01),df=n-2), 0), 
        col = 'blue',density=50)
polygon(x = c(-10, seq(-10,-2.306004,  0.01), -2.306004),
        y = c(0, dt(seq(-10,-2.306004,  0.01),df=n-2), 0), 
        col = 'blue',density=50)
abline(v=c(inf,sup), lty=3, col="blue")
text(-4,0.1, "Região de rejeição",col = "blue",cex = 1,srt = 90)
text(4,0.1, "Região de rejeição",col = "blue",cex = 1,srt = 90)
abline(v=test.c(r,n), lty=3, col="red")
text(8,0.1, "t.calc > t.crit",col = "red",cex = 1,srt = 90)
```


## Gráfico para duas variáveis no eixo y


```{r}
# Construção do gráfico das variáveis com dois diferentes eixos y
# dev.off() # Limpa padrão gráfico
x<-1:10 # Eixo x
par(mar=c(5.1, 4.1, 4.1, 6.1)) # Estipula as margens para plotar o gráfico

## Primeiro eixo: Consumo
plot(x, consumo, pch=16, axes=FALSE, xlab="", ylab="", 
     type="b",col="black", main="Consumo x Distância")
# Eixo para a variável consumo
axis(2, ylim=c(0,max(consumo)),col="black") 
mtext("Consumo",side=2,line=2,col="black")
## Permitir uma nova figura no mesmo gráfico
par(new=TRUE)

## Segundo eixe: Distância
plot(x,distancia, pch=15,  xlab="", ylab="", 
     axes=FALSE, type="b", col="red")
# Eixo para a variável consumo
axis(4, ylim=c(0,max(distancia)),col="red",col.axis="red") 
mtext("Distância",side=4,line=2,col="red")

## Eixo x
axis(1,1:10)
mtext("Amostra",side=1,col="black",line=2)  

## Adicionando a legenda
legend("topleft",legend=c("Consumo","Distância"),
       text.col=c("black","red"),pch=c(16,15),col=c("black","red"))

```


```{r}
# help(mtcars)
head(mtcars)
```

```{r}
summary(mtcars)
```

```{r}
# Variáveis selecionadas
dat<-mtcars[,c(1,2,3,4,5,6,7,8)]
```


```{r}
# Verifica se há dado faltante
is.na(dat)
```

```{r}
# Verifica a quantidade de dados faltantes
sum(is.na(dat))
```
```{r}
# Matriz de correlação
res <- cor(dat)
res
round(res, 2)
```

## Outras formas de visualizar a correlação entre variáveis

```{r}
# Biblioteca PerformanceAnalytics
library("PerformanceAnalytics")
chart.Correlation(dat, histogram = TRUE)

```

```{r}
# Bibioteca GGally
# install.packages("GGally")
library(GGally)
ggpairs(dat)
ggcorr(dat, nbreaks=8, palette='RdGy', label=TRUE, label_size=5, label_color='white')
```


```{r}
# Biblioteca corrplot
# install.packages("corrplot")
library(corrplot)

corrplot(cor(dat), method = "circle") # method = "circle" é o default
corrplot(cor(dat), method ='number')
corrplot(cor(dat), type = "upper")
corrplot(cor(dat), type = "lower")
corrplot.mixed(cor(dat))
```

# Regressão Linear Simples (03/11/20)

## Exemplo Renda x Despesa

```{r,fig.height=6,fig.width=9}
Renda<-c(2,4,6,5,3,7,6,7,5,4,3,2,1)
Despesas<-c(1,2,3,3,1,3,3.5,4,2.5,2,1.5,1,1)
base<-data.frame(Renda,Despesas)
head(base)
plot(base$Renda, base$Despesas, main= "Renda x despesas", ylab= "Despesas", xlab="Renda", ylim=c(0,5),xlim=c(0,8), pch=16, col="blue",cex.main=1.5, cex=1.5,cex.lab=1.2, 
     cex.axis=1,bty="l")
abline(h=seq(0,5,0.5), v=seq(0,8,0.5), lty=3, col="gray")
lines(0:8,rep(mean(base$Despesas),9), col="black")
lines(0:8,(0:8)/2, col="green")
lines(0:8,0.05233+0.50581*0:8, col="red")
legend("topleft",legend=c("Modelo 1: Y=2.2 + e","Modelo 2: Y=X/2 + e",
                          "Modelo 3: Y=0.05233+0.50581X + e"),
       text.col=c("black","green","red"),col=c("black","green","red"))

# Modelos possíveis
model1<-rep(mean(base$Renda),length(base$Renda))
model1
model2<-base$Renda/2
model2
model3<-0.05233+0.50581*base$Renda
model3
# Erro quadrático médio
sum((base$Despesas-model1)^2)/length(base$Despesas)
sum((base$Despesas-model2)^2)/length(base$Despesas)
sum((base$Despesas-model3)^2)/length(base$Despesas)

```

## Exercício 1 continuação

```{r}
# x:Distancia y:Consumo
# Construindo a fórmula
Distancia<-scan(text="20.00 60.00 15.00 45.00 35.00 80.00 70.00 73.00 28.00 85.00")
Consumo<-scan(text="1.33 5.45 1.66 3.46 2.92 6.15 4.11 5.00 2.95 6.54")
sumxy<-sum(Distancia*Consumo)
xbarra<-mean(Distancia)
ybarra<-mean(Consumo)
sumx2<-sum(Distancia^2)
n<-length(Distancia)
beta1<-(sumxy-n*xbarra*ybarra)/(sumx2-n*(xbarra^2))
beta0<-ybarra-beta1*xbarra
beta1
beta0

# Construindo a função
estima<-function(Distancia,Consumo){
  sumxy<-sum(Distancia*Consumo)
  xbarra<-mean(Distancia)
  ybarra<-mean(Consumo)
  sumx2<-sum(Distancia^2)
  n<-length(Distancia)
  beta1<-(sumxy-n*xbarra*ybarra)/(sumx2-n*(xbarra^2))
  beta0<-ybarra-beta1*xbarra
  return(list(Beta0=beta0,Beta1=beta1))
}

estima(Distancia,Consumo)
# Resultado pela função do R y~x
model<-lm(Consumo~Distancia)

# Coeficientes do modelo
coef(model)
# Valores preditos
predict(model)
# Resíduos
residuals(model)
#Resíduos
predict(model)-Consumo
# Avaliação dos resíduos pelo gráfico
plot(resid(model) ~ predict(model),pch=16, ylab= "Resíduo", xlab="Y esperado",
     cex.main=1.5, cex=1.5,cex.lab=1.2, cex.axis=1,bty="l") # Resíduos vs. Y esperado
abline(0,0,col="red")
# Avaliação gráfica
par(mfrow=c(2,2))
plot(model)

# A variabilidade em Y causada por uma unidade em X é de 0.06625223
#Limpa padrão gráfico
dev.off()
```
```{r}
# Gráfico de dispersão com o modelo ajustado
plot(Distancia, Consumo, main="Consumo x Distância", ylab= "Consumo (l)", xlab="Distância (km)",
     pch=16, col="blue",cex.main=1.5, cex=1.5,cex.lab=1.2, cex.axis=1,bty="l")
abline(h=seq(0,7,1), v=seq(0,90, 10), lty=3, col="gray")
abline(model,col="red") 
text(30,5,"Y=0.57+0.066X+e", col="red")

```
```{r}
# Predição do consumo de combustível para uma distância de 37.00 km
#Acrescenta predição na função
estima<-function(Distancia,Consumo,valor){
  sumxy<-sum(Distancia*Consumo)
  xbarra<-mean(Distancia)
  ybarra<-mean(Consumo)
  sumx2<-sum(Distancia^2)
  n<-length(Distancia)
  beta1<-(sumxy-n*xbarra*ybarra)/(sumx2-n*(xbarra^2))
  beta0<-ybarra-beta1*xbarra
  pred<-beta0+beta1*valor
  return(list(Beta0=beta0,Beta1=beta1,Predição=pred))
}
estima(Distancia, Consumo, 37.00)

```
```{r}
# Supondo um ponto discrepante
cor(Distancia,Consumo) #Anterior a inclusão de outlier
Distancia<-c(Distancia,40)
Consumo<-c(Consumo,20)
cor(Distancia,Consumo)
plot(Distancia,Consumo, main="Consumo x Distância", ylab= "Consumo (l)", xlab="Distância (km)",
     pch=16, col="blue",cex.main=1.5, cex=1.5,cex.lab=1.2, cex.axis=1,bty="l")
abline(h=seq(0,20,1), v=seq(0,90, 10), lty=3, col="gray")
model2<-lm(Consumo~Distancia)
abline(model,col="red")
abline(model2,col="blue")
# Supondo mais um ponto discrepante
Distancia<-c(Distancia,10)
Consumo<-c(Consumo,15)
cor(Distancia,Consumo)
# Gráfico com os pontos discrepantes e o ajuste
plot(Distancia,Consumo, main="Consumo x Distância", ylab= "Consumo (l)", xlab="Distância (km)",
     pch=16, col="blue",cex.main=1.5, cex=1.5,cex.lab=1.2, cex.axis=1,bty="l")
abline(h=seq(0,20,1), v=seq(0,90, 10), lty=3, col="gray")
model3<-lm(Consumo~Distancia)
abline(model,col="red") 
abline(model2,col="blue") # Incluindo um dado doscrepante
abline(model3,col="green") # Incluindo dois dados doscrepantes
par(mfrow=c(2,2))
plot(model3)
```

## Quarteto Asconbe

```{r}
# Este exemplo mostra a importância da visualização dos dados.
# O quarteto Anscombes contém 4 conjuntos de dados x, y, Francis Anscombe publicou um paper a respeito em 1973.
head(anscombe)
# Média
sapply(1:8, function(x) mean(anscombe[ , x]))
# Variância
sapply(1:8, function(x) var(anscombe[ , x]))
# Coorelação
sapply(1:4, function(x) cor(anscombe[ , x], anscombe[ , x+4]))

par(mfrow=c(2,2))
plot(y1~x1,anscombe,main = "y1 ~ x1",col="blue",pch=16)
plot(y2~x2,anscombe,main = "y2 ~ x2",col="blue",pch=16)
plot(y3~x3,anscombe,main = "y3 ~ x3",col="blue",pch=16)
plot(y4~x4,anscombe,main = "y4 ~ x4",col="blue",pch=16)
model1<-lm(y1~x1,anscombe)
model1
model2<-lm(y2~x2,anscombe)
model2
model3<-lm(y3~x3,anscombe)
model3
model4<-lm(y4~x4,anscombe)
model4
par(mfrow=c(2,2))
plot(y1~x1,anscombe,main = "y1 ~ x1",col="blue",pch=16)
abline(model1, col="red")
plot(y2~x2,anscombe,main = "y2 ~ x2",col="blue",pch=16)
abline(model2, col="red")
plot(y3~x3,anscombe,main = "y3 ~ x3",col="blue",pch=16)
abline(model3, col="red")
plot(y4~x4,anscombe,main = "y4 ~ x4",col="blue",pch=16)
abline(model4, col="red")

```
```{r}
#Livro: Noções de probabilidade e Estatística. Marcos N. Magalhães e Antonio Carlos P. Lima. 7 #edição, 2015. 
url <- "https://felipebarletta.github.io/DAEST/questionario.txt"
filename <- "questionario.txt" 
downloader::download(url, destfile=filename)
dat<-read.table("questionario.txt",head=T)
head(dat)
#install.packages("ggplot2")
library(ggplot2)
ggplot(data=dat,aes(y=Peso,x=Alt))+
  geom_point(aes(color = factor(Sexo)))+
  stat_smooth(method = "lm",
        col = "black",
        se = FALSE,
        size = 1)+
  labs( x = "Altura",
        y = "Peso",
        color = "Sexo",
        title = "Peso x Altura"
    )

# Qualidade do ajuste pelo ggplot
mod<-lm(Peso~Alt,data=dat)
# Resíduos vs predito.
ggplot(mod, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE)
# Resíduos padronizado vs predito
ggplot(mod, aes(.fitted, sqrt(abs(.stdresid)))) +
  geom_point() +
  geom_smooth(se = FALSE)
# Normalidade
ggplot(mod) +
  stat_qq(aes(sample = .stdresid)) +
  geom_abline()

```


